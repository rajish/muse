// Generated by <a href="http://scalaxb.org/">scalaxb</a>.
package XuseProtocol
    
/**
usage:
val obj = scalaxb.fromXML[XuseProtocol.Foo](node)
val document = scalaxb.toXML[XuseProtocol.Foo](obj, "foo", XuseProtocol.defaultScope)
**/
object `package` extends XMLProtocol { }

trait XMLProtocol extends scalaxb.XMLStandardTypes {
  val defaultScope = scalaxb.toScope(None -> "http://xuse.sourceforge.net",
    Some("xi") -> "http://www.w3.org/2001/XInclude",
    Some("xs") -> "http://www.w3.org/2001/XMLSchema",
    Some("xsi") -> "http://www.w3.org/2001/XMLSchema-instance",
    Some("xtr") -> "http://www.xml-solutions.com/xuse/trace-report",
    Some("xuse") -> "http://xuse.sourceforge.net")
  implicit lazy val ModelsActorsFormat: scalaxb.XMLFormat[models.Actors] = new DefaultModelsActorsFormat {}
  implicit lazy val ModelsActorTypeFormat: scalaxb.XMLFormat[models.ActorType] = new DefaultModelsActorTypeFormat {}
  implicit lazy val ModelsActorStereotypeTypeFormat: scalaxb.XMLFormat[models.ActorStereotypeType] = new DefaultModelsActorStereotypeTypeFormat {}
  implicit lazy val ModelsTypeFormat: scalaxb.XMLFormat[models.Type] = new DefaultModelsTypeFormat {}
  implicit lazy val ModelsParentFormat: scalaxb.XMLFormat[models.Parent] = new DefaultModelsParentFormat {}
  implicit lazy val ModelsRequirementTypesFormat: scalaxb.XMLFormat[models.RequirementTypes] = new DefaultModelsRequirementTypesFormat {}
  implicit lazy val ModelsStrengthFormat: scalaxb.XMLFormat[models.Strength] = new DefaultModelsStrengthFormat {}
  implicit lazy val ModelsRequirementTypeFormat: scalaxb.XMLFormat[models.RequirementType] = new DefaultModelsRequirementTypeFormat {}
  implicit lazy val ModelsTitleTypeFormat: scalaxb.XMLFormat[models.TitleType] = new DefaultModelsTitleTypeFormat {}
  implicit lazy val ModelsDescriptionTypeFormat: scalaxb.XMLFormat[models.DescriptionType] = new DefaultModelsDescriptionTypeFormat {}
  implicit lazy val ModelsNarrativeTypeFormat: scalaxb.XMLFormat[models.NarrativeType] = new DefaultModelsNarrativeTypeFormat {}
  implicit lazy val ModelsTaxonomyTypeFormat: scalaxb.XMLFormat[models.TaxonomyType] = new DefaultModelsTaxonomyTypeFormat {}
  implicit lazy val ModelsClassificationTypeFormat: scalaxb.XMLFormat[models.ClassificationType] = new DefaultModelsClassificationTypeFormat {}
  implicit lazy val ModelsPackageTypeFormat: scalaxb.XMLFormat[models.PackageType] = new DefaultModelsPackageTypeFormat {}
  implicit lazy val ModelsStatusTypeFormat: scalaxb.XMLFormat[models.StatusType] = new DefaultModelsStatusTypeFormat {}
  implicit lazy val ModelsAudienceTypeFormat: scalaxb.XMLFormat[models.AudienceType] = new DefaultModelsAudienceTypeFormat {}
  implicit lazy val ModelsActoru45refTypeFormat: scalaxb.XMLFormat[models.Actoru45refType] = new DefaultModelsActoru45refTypeFormat {}
  implicit lazy val ModelsStakeholderu45refTypeFormat: scalaxb.XMLFormat[models.Stakeholderu45refType] = new DefaultModelsStakeholderu45refTypeFormat {}
  implicit lazy val ModelsExternalu45linkTypeFormat: scalaxb.XMLFormat[models.Externalu45linkType] = new DefaultModelsExternalu45linkTypeFormat {}
  implicit lazy val ModelsDocumentu45historyTypeFormat: scalaxb.XMLFormat[models.Documentu45historyType] = new DefaultModelsDocumentu45historyTypeFormat {}
  implicit lazy val ModelsVersionTypeFormat: scalaxb.XMLFormat[models.VersionType] = new DefaultModelsVersionTypeFormat {}
  implicit lazy val ModelsRequirementu45refTypeFormat: scalaxb.XMLFormat[models.Requirementu45refType] = new DefaultModelsRequirementu45refTypeFormat {}
  implicit lazy val ModelsStereotypeFormat: scalaxb.XMLFormat[models.Stereotype] = new DefaultModelsStereotypeFormat {}
  implicit lazy val ModelsUseu45caseu45refTypeFormat: scalaxb.XMLFormat[models.Useu45caseu45refType] = new DefaultModelsUseu45caseu45refTypeFormat {}
  implicit lazy val ModelsReleaseRefTypeFormat: scalaxb.XMLFormat[models.ReleaseRefType] = new DefaultModelsReleaseRefTypeFormat {}
  implicit lazy val ModelsRequirementsCollectionTypeFormat: scalaxb.XMLFormat[models.RequirementsCollectionType] = new DefaultModelsRequirementsCollectionTypeFormat {}
  implicit lazy val ModelsAnnotationTypeFormat: scalaxb.XMLFormat[models.AnnotationType] = new DefaultModelsAnnotationTypeFormat {}
  implicit lazy val ModelsCommentsTypeFormat: scalaxb.XMLFormat[models.CommentsType] = new DefaultModelsCommentsTypeFormat {}
  implicit lazy val ModelsCommentTypeFormat: scalaxb.XMLFormat[models.CommentType] = new DefaultModelsCommentTypeFormat {}
  implicit lazy val ModelsStakeholderTypeFormat: scalaxb.XMLFormat[models.StakeholderType] = new DefaultModelsStakeholderTypeFormat {}
  implicit lazy val ModelsDictionaryFormat: scalaxb.XMLFormat[models.Dictionary] = new DefaultModelsDictionaryFormat {}
  implicit lazy val ModelsDictionaryEntryTypeFormat: scalaxb.XMLFormat[models.DictionaryEntryType] = new DefaultModelsDictionaryEntryTypeFormat {}
  implicit lazy val ModelsValueTypeFormat: scalaxb.XMLFormat[models.ValueType] = new DefaultModelsValueTypeFormat {}
  implicit lazy val ModelsGlossaryFormat: scalaxb.XMLFormat[models.Glossary] = new DefaultModelsGlossaryFormat {}
  implicit lazy val ModelsGlossaryEntryTypeFormat: scalaxb.XMLFormat[models.GlossaryEntryType] = new DefaultModelsGlossaryEntryTypeFormat {}
  implicit lazy val ModelsRequirementsFormat: scalaxb.XMLFormat[models.Requirements] = new DefaultModelsRequirementsFormat {}
  implicit lazy val ModelsStakeholdersFormat: scalaxb.XMLFormat[models.Stakeholders] = new DefaultModelsStakeholdersFormat {}
  implicit lazy val ModelsTraceu45reportTypeFormat: scalaxb.XMLFormat[models.Traceu45reportType] = new DefaultModelsTraceu45reportTypeFormat {}
  implicit lazy val ModelsClassFormat: scalaxb.XMLFormat[models.Class] = new DefaultModelsClassFormat {}
  implicit lazy val ModelsTraceu45toFormat: scalaxb.XMLFormat[models.Traceu45to] = new DefaultModelsTraceu45toFormat {}
  implicit lazy val ModelsArtefactTypeFormat: scalaxb.XMLFormat[models.ArtefactType] = new DefaultModelsArtefactTypeFormat {}
  implicit lazy val ModelsBuiltu45inu45artefactu45classifiersTypeFormat: scalaxb.XMLFormat[models.Builtu45inu45artefactu45classifiersType] = new DefaultModelsBuiltu45inu45artefactu45classifiersTypeFormat {}
  implicit lazy val ModelsUseu45caseTypeFormat: scalaxb.XMLFormat[models.Useu45caseType] = new DefaultModelsUseu45caseTypeFormat {}
  implicit lazy val ModelsUseu45caseu45propertiesTypeFormat: scalaxb.XMLFormat[models.Useu45caseu45propertiesType] = new DefaultModelsUseu45caseu45propertiesTypeFormat {}
  implicit lazy val ModelsSequenceTypableFormat: scalaxb.XMLFormat[models.SequenceTypable] = new DefaultModelsSequenceTypableFormat {}
  implicit lazy val ModelsSequenceTypeFormat: scalaxb.XMLFormat[models.SequenceType] = new DefaultModelsSequenceTypeFormat {}
  implicit lazy val ModelsMainSequenceTypeFormat: scalaxb.XMLFormat[models.MainSequenceType] = new DefaultModelsMainSequenceTypeFormat {}
  implicit lazy val ModelsRejoinFormat: scalaxb.XMLFormat[models.Rejoin] = new DefaultModelsRejoinFormat {}
  implicit lazy val ModelsAlternateSequenceTypeFormat: scalaxb.XMLFormat[models.AlternateSequenceType] = new DefaultModelsAlternateSequenceTypeFormat {}
  implicit lazy val ModelsStepTypeFormat: scalaxb.XMLFormat[models.StepType] = new DefaultModelsStepTypeFormat {}
  implicit lazy val ModelsAlternateu45flowsTypeFormat: scalaxb.XMLFormat[models.Alternateu45flowsType] = new DefaultModelsAlternateu45flowsTypeFormat {}
  implicit lazy val ModelsRefu45alternateu45flowsTypeFormat: scalaxb.XMLFormat[models.Refu45alternateu45flowsType] = new DefaultModelsRefu45alternateu45flowsTypeFormat {}
  implicit lazy val ModelsExceptionu45flowsTypeFormat: scalaxb.XMLFormat[models.Exceptionu45flowsType] = new DefaultModelsExceptionu45flowsTypeFormat {}
  implicit lazy val ModelsIncludeTypeFormat: scalaxb.XMLFormat[models.IncludeType] = new DefaultModelsIncludeTypeFormat {}
  implicit lazy val ModelsParseTypeFormat: scalaxb.XMLFormat[models.ParseType] = new DefaultModelsParseTypeFormat {}
  implicit lazy val ModelsFallbackTypeFormat: scalaxb.XMLFormat[models.FallbackType] = new DefaultModelsFallbackTypeFormat {}

  trait DefaultModelsActorsFormat extends scalaxb.ElemNameParser[models.Actors] {
    val targetNamespace: Option[String] = Some("http://xuse.sourceforge.net")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[models.Actors] =
      phrase(rep(scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "actor")) ^^
      { case p1 =>
      models.Actors(p1.toSeq map { scalaxb.fromXML[models.ActorType](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[String](scala.xml.Text("1.0"), scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "model-version" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) })
    
    override def writesAttribute(__obj: models.Actors, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "model-version", __obj.modelu45version.toString, attr)
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: models.Actors, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.actor flatMap { scalaxb.toXML[models.ActorType](_, Some("http://xuse.sourceforge.net"), Some("actor"), __scope, false) })

  }

  trait DefaultModelsActorTypeFormat extends scalaxb.ElemNameParser[models.ActorType] {
    val targetNamespace: Option[String] = Some("http://xuse.sourceforge.net")
    
    override def typeName: Option[String] = Some("actorType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[models.ActorType] =
      phrase((scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "title")) ~ 
      (scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "description")) ~ 
      opt(scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "stereotype")) ~ 
      rep(any(_.namespace != Some("http://xuse.sourceforge.net"))) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      models.ActorType(scalaxb.fromXML[String](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[models.DescriptionType](p2, scalaxb.ElemName(node) :: stack),
        p3.headOption map { scalaxb.fromXML[models.ActorStereotypeType](_, scalaxb.ElemName(node) :: stack) },
        p4.toSeq map { scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[String]((node \ "@id"), scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) })
    
    override def writesAttribute(__obj: models.ActorType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "id", __obj.id.toString, attr)
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: models.ActorType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[String](__obj.title, Some("http://xuse.sourceforge.net"), Some("title"), __scope, false),
        scalaxb.toXML[models.DescriptionType](__obj.description, Some("http://xuse.sourceforge.net"), Some("description"), __scope, false),
        __obj.stereotype map { scalaxb.toXML[models.ActorStereotypeType](_, Some("http://xuse.sourceforge.net"), Some("stereotype"), __scope, false) } getOrElse {Nil},
        __obj.any flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, true) })

  }

  def buildModelsActorStereotypeTypeFormat = new DefaultModelsActorStereotypeTypeFormat {}
  trait DefaultModelsActorStereotypeTypeFormat extends scalaxb.XMLFormat[models.ActorStereotypeType] {
    val targetNamespace: Option[String] = Some("http://xuse.sourceforge.net")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, models.ActorStereotypeType] = seq match {
      case elem: scala.xml.Elem => Right(models.ActorStereotypeType.fromString(elem.text, elem.scope))
      case _ => Right(models.ActorStereotypeType.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: models.ActorStereotypeType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, scala.xml.Text(__obj.toString))
  }

  trait DefaultModelsTypeFormat extends scalaxb.XMLFormat[models.Type] with scalaxb.CanWriteChildNodes[models.Type] {
    val targetNamespace: Option[String] = Some("http://xuse.sourceforge.net")
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, models.Type] = seq match {
      case node: scala.xml.Node => Right(models.Type(scalaxb.fromXML[models.RequirementTypes](node, scalaxb.ElemName(node) :: stack),
        (node \ "@is-feature").headOption map { scalaxb.fromXML[Boolean](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: models.Type, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.isu45feature foreach { x => attr = scala.xml.Attribute(null, "is-feature", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: models.Type, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultModelsParentFormat extends scalaxb.XMLFormat[models.Parent] with scalaxb.CanWriteChildNodes[models.Parent] {
    val targetNamespace: Option[String] = Some("http://xuse.sourceforge.net")
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, models.Parent] = seq match {
      case node: scala.xml.Node => Right(models.Parent(scalaxb.fromXML[String]((node \ "@refId"), scalaxb.ElemName(node) :: stack)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: models.Parent, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "refId", __obj.refId.toString, attr)
      attr
    }

    def writesChildNodes(__obj: models.Parent, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  def buildModelsRequirementTypesFormat = new DefaultModelsRequirementTypesFormat {}
  trait DefaultModelsRequirementTypesFormat extends scalaxb.XMLFormat[models.RequirementTypes] {
    val targetNamespace: Option[String] = Some("http://xuse.sourceforge.net")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, models.RequirementTypes] = seq match {
      case elem: scala.xml.Elem => Right(models.RequirementTypes.fromString(elem.text, elem.scope))
      case _ => Right(models.RequirementTypes.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: models.RequirementTypes, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, scala.xml.Text(__obj.toString))
  }

  def buildModelsStrengthFormat = new DefaultModelsStrengthFormat {}
  trait DefaultModelsStrengthFormat extends scalaxb.XMLFormat[models.Strength] {
    val targetNamespace: Option[String] = Some("http://xuse.sourceforge.net")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, models.Strength] = seq match {
      case elem: scala.xml.Elem => Right(models.Strength.fromString(elem.text, elem.scope))
      case _ => Right(models.Strength.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: models.Strength, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, scala.xml.Text(__obj.toString))
  }

  trait DefaultModelsRequirementTypeFormat extends scalaxb.ElemNameParser[models.RequirementType] {
    val targetNamespace: Option[String] = Some("http://xuse.sourceforge.net")
    
    override def typeName: Option[String] = Some("requirementType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[models.RequirementType] =
      phrase(rep(scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "annotation")) ~ 
      opt(scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "title")) ~ 
      (scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "description")) ~ 
      opt(scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "author")) ~ 
      opt(scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "classification")) ~ 
      opt(scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "parent")) ~ 
      rep(scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "req-ref")) ~ 
      rep(scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "stakeholder-ref")) ~ 
      rep(scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "external-link")) ~ 
      rep(any(_.namespace != Some("http://xuse.sourceforge.net"))) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 =>
      models.RequirementType(p1.toSeq map { scalaxb.fromXML[models.AnnotationType](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[models.TitleType](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[models.DescriptionType](p3, scalaxb.ElemName(node) :: stack),
        p4.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p5.headOption map { scalaxb.fromXML[models.ClassificationType](_, scalaxb.ElemName(node) :: stack) },
        p6.headOption map { scalaxb.fromXML[models.Parent](_, scalaxb.ElemName(node) :: stack) },
        p7.toSeq map { _.nilOption map { scalaxb.fromXML[models.Requirementu45refType](_, scalaxb.ElemName(node) :: stack) }},
        p8.toSeq map { _.nilOption map { scalaxb.fromXML[models.Stakeholderu45refType](_, scalaxb.ElemName(node) :: stack) }},
        p9.toSeq map { _.nilOption map { scalaxb.fromXML[models.Externalu45linkType](_, scalaxb.ElemName(node) :: stack) }},
        p10.toSeq map { scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[String]((node \ "@id"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[Double]((node \ "@version"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[models.Strength]((node \ "@strength"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String]((node \ "@creation-date"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String]((node \ "@modification-date"), scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "version" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "strength" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "creation-date" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "modification-date" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) })
    
    override def writesAttribute(__obj: models.RequirementType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "id", __obj.id.toString, attr)
      attr = scala.xml.Attribute(null, "version", __obj.version.toString, attr)
      attr = scala.xml.Attribute(null, "strength", __obj.strength.toString, attr)
      attr = scala.xml.Attribute(null, "creation-date", __obj.creationu45date.toString, attr)
      attr = scala.xml.Attribute(null, "modification-date", __obj.modificationu45date.toString, attr)
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: models.RequirementType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[models.AnnotationType](_, Some("http://xuse.sourceforge.net"), Some("annotation"), __scope, false) },
        __obj.title map { scalaxb.toXML[models.TitleType](_, Some("http://xuse.sourceforge.net"), Some("title"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[models.DescriptionType](__obj.description, Some("http://xuse.sourceforge.net"), Some("description"), __scope, false),
        __obj.author map { scalaxb.toXML[String](_, Some("http://xuse.sourceforge.net"), Some("author"), __scope, false) } getOrElse {Nil},
        __obj.classification map { scalaxb.toXML[models.ClassificationType](_, Some("http://xuse.sourceforge.net"), Some("classification"), __scope, false) } getOrElse {Nil},
        __obj.parent map { scalaxb.toXML[models.Parent](_, Some("http://xuse.sourceforge.net"), Some("parent"), __scope, false) } getOrElse {Nil},
        __obj.requ45ref flatMap { scalaxb.toXML[Option[models.Requirementu45refType]](_, Some("http://xuse.sourceforge.net"), Some("req-ref"), __scope, false) },
        __obj.stakeholderu45ref flatMap { scalaxb.toXML[Option[models.Stakeholderu45refType]](_, Some("http://xuse.sourceforge.net"), Some("stakeholder-ref"), __scope, false) },
        __obj.externalu45link flatMap { scalaxb.toXML[Option[models.Externalu45linkType]](_, Some("http://xuse.sourceforge.net"), Some("external-link"), __scope, false) },
        __obj.any flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, true) })

  }

  trait DefaultModelsTitleTypeFormat extends scalaxb.ElemNameParser[models.TitleType] with ModelsReplacementu45textu45elementsu45groupGroupFormat {
    val targetNamespace: Option[String] = Some("http://xuse.sourceforge.net")
    
    override def typeName: Option[String] = Some("titleType")

    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[models.TitleType] =
      phrase(optTextRecord ~ 
      rep((parsemixedReplacementu45textu45elementsu45groupGroup(node, scalaxb.ElemName(node) :: stack))) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      models.TitleType(Seq.concat(p1.toList,
        p2.flatten,
        p3.toList)) })
    
    def writesChildNodes(__obj: models.TitleType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultModelsDescriptionTypeFormat extends scalaxb.ElemNameParser[models.DescriptionType] with ModelsReferenceTypeu45groupGroupFormat with ModelsReplacementu45textu45elementsu45groupGroupFormat {
    val targetNamespace: Option[String] = Some("http://xuse.sourceforge.net")
    
    override def typeName: Option[String] = Some("descriptionType")

    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[models.DescriptionType] =
      phrase(optTextRecord ~ 
      rep(((parsemixedReferenceTypeu45groupGroup(node, scalaxb.ElemName(node) :: stack)) ||| 
      (parsemixedReplacementu45textu45elementsu45groupGroup(node, scalaxb.ElemName(node) :: stack))) | 
      (((any(_.namespace != Some("http://xuse.sourceforge.net")) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack))) ~ 
      optTextRecord) ^^ 
      { case p1 ~ p2 => Seq.concat(Seq(p1), p2.toList) })) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      models.DescriptionType(Seq.concat(p1.toList,
        p2.flatten,
        p3.toList),
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) })
    
    override def writesAttribute(__obj: models.DescriptionType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: models.DescriptionType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  trait DefaultModelsNarrativeTypeFormat extends scalaxb.XMLFormat[models.NarrativeType] with scalaxb.CanWriteChildNodes[models.NarrativeType] {
    val targetNamespace: Option[String] = Some("http://xuse.sourceforge.net")
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, models.NarrativeType] = seq match {
      case node: scala.xml.Node => Right(models.NarrativeType(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def writesChildNodes(__obj: models.NarrativeType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultModelsTaxonomyTypeFormat extends scalaxb.XMLFormat[models.TaxonomyType] with scalaxb.CanWriteChildNodes[models.TaxonomyType] {
    val targetNamespace: Option[String] = Some("http://xuse.sourceforge.net")
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, models.TaxonomyType] = seq match {
      case node: scala.xml.Node => Right(models.TaxonomyType(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String]((node \ "@classifier"), scalaxb.ElemName(node) :: stack)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: models.TaxonomyType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "classifier", __obj.classifier.toString, attr)
      attr
    }

    def writesChildNodes(__obj: models.TaxonomyType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultModelsClassificationTypeFormat extends scalaxb.ElemNameParser[models.ClassificationType] {
    val targetNamespace: Option[String] = Some("http://xuse.sourceforge.net")
    
    override def typeName: Option[String] = Some("classificationType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[models.ClassificationType] =
      phrase((scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "type")) ~ 
      (scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "status")) ~ 
      rep(any(_ => true)) ~ 
      rep(scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "taxonomy")) ~ 
      rep(any(_.namespace != Some("http://xuse.sourceforge.net"))) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      models.ClassificationType(p1.headOption map { scalaxb.fromXML[models.Type](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[models.Type](scala.xml.Text("functional"), scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[models.StatusType](p2, scalaxb.ElemName(node) :: stack),
        p3.toSeq map { scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack) },
        p4.toSeq map { scalaxb.fromXML[models.TaxonomyType](_, scalaxb.ElemName(node) :: stack) },
        p5.toSeq map { scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) })
    
    override def writesAttribute(__obj: models.ClassificationType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: models.ClassificationType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[models.Type](__obj.typeValue, Some("http://xuse.sourceforge.net"), Some("type"), __scope, false),
        scalaxb.toXML[models.StatusType](__obj.status, Some("http://xuse.sourceforge.net"), Some("status"), __scope, false),
        __obj.packageValue flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, true) },
        __obj.taxonomy flatMap { scalaxb.toXML[models.TaxonomyType](_, Some("http://xuse.sourceforge.net"), Some("taxonomy"), __scope, false) },
        __obj.any flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, true) })

  }

  trait DefaultModelsPackageTypeFormat extends scalaxb.XMLFormat[models.PackageType] with scalaxb.CanWriteChildNodes[models.PackageType] {
    val targetNamespace: Option[String] = Some("http://xuse.sourceforge.net")
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, models.PackageType] = seq match {
      case node: scala.xml.Node => Right(models.PackageType(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    def writesChildNodes(__obj: models.PackageType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  def buildModelsStatusTypeFormat = new DefaultModelsStatusTypeFormat {}
  trait DefaultModelsStatusTypeFormat extends scalaxb.XMLFormat[models.StatusType] {
    val targetNamespace: Option[String] = Some("http://xuse.sourceforge.net")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, models.StatusType] = seq match {
      case elem: scala.xml.Elem => Right(models.StatusType.fromString(elem.text, elem.scope))
      case _ => Right(models.StatusType.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: models.StatusType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, scala.xml.Text(__obj.toString))
  }

  def buildModelsAudienceTypeFormat = new DefaultModelsAudienceTypeFormat {}
  trait DefaultModelsAudienceTypeFormat extends scalaxb.XMLFormat[models.AudienceType] {
    val targetNamespace: Option[String] = Some("http://xuse.sourceforge.net")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, models.AudienceType] = seq match {
      case elem: scala.xml.Elem => Right(models.AudienceType.fromString(elem.text, elem.scope))
      case _ => Right(models.AudienceType.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: models.AudienceType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, scala.xml.Text(__obj.toString))
  }

  trait DefaultModelsActoru45refTypeFormat extends scalaxb.XMLFormat[models.Actoru45refType] with scalaxb.CanWriteChildNodes[models.Actoru45refType] {
    val targetNamespace: Option[String] = Some("http://xuse.sourceforge.net")
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, models.Actoru45refType] = seq match {
      case node: scala.xml.Node => Right(models.Actoru45refType(scalaxb.fromXML[String]((node \ "@refId"), scalaxb.ElemName(node) :: stack)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: models.Actoru45refType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "refId", __obj.refId.toString, attr)
      attr
    }

    def writesChildNodes(__obj: models.Actoru45refType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultModelsStakeholderu45refTypeFormat extends scalaxb.XMLFormat[models.Stakeholderu45refType] with scalaxb.CanWriteChildNodes[models.Stakeholderu45refType] {
    val targetNamespace: Option[String] = Some("http://xuse.sourceforge.net")
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, models.Stakeholderu45refType] = seq match {
      case node: scala.xml.Node => Right(models.Stakeholderu45refType(scalaxb.fromXML[String]((node \ "@refId"), scalaxb.ElemName(node) :: stack)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: models.Stakeholderu45refType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "refId", __obj.refId.toString, attr)
      attr
    }

    def writesChildNodes(__obj: models.Stakeholderu45refType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultModelsExternalu45linkTypeFormat extends scalaxb.XMLFormat[models.Externalu45linkType] with scalaxb.CanWriteChildNodes[models.Externalu45linkType] {
    val targetNamespace: Option[String] = Some("http://xuse.sourceforge.net")
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, models.Externalu45linkType] = seq match {
      case node: scala.xml.Node => Right(models.Externalu45linkType(scalaxb.fromXML[String]((node \ "@refId"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String]((node \ "@type"), scalaxb.ElemName(node) :: stack),
        (node \ "@href").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: models.Externalu45linkType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "refId", __obj.refId.toString, attr)
      attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
      __obj.href foreach { x => attr = scala.xml.Attribute(null, "href", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: models.Externalu45linkType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultModelsDocumentu45historyTypeFormat extends scalaxb.ElemNameParser[models.Documentu45historyType] {
    val targetNamespace: Option[String] = Some("http://xuse.sourceforge.net")
    
    override def typeName: Option[String] = Some("document-historyType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[models.Documentu45historyType] =
      phrase(rep(scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "version")) ~ 
      rep(any(_.namespace != Some("http://xuse.sourceforge.net"))) ^^
      { case p1 ~ p2 =>
      models.Documentu45historyType(p1.toSeq map { scalaxb.fromXML[models.VersionType](_, scalaxb.ElemName(node) :: stack) },
        p2.toSeq map { scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[String]((node \ "@current-version"), scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "current-version" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) })
    
    override def writesAttribute(__obj: models.Documentu45historyType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "current-version", __obj.currentu45version.toString, attr)
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: models.Documentu45historyType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.version flatMap { scalaxb.toXML[models.VersionType](_, Some("http://xuse.sourceforge.net"), Some("version"), __scope, false) },
        __obj.any flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, true) })

  }

  trait DefaultModelsVersionTypeFormat extends scalaxb.ElemNameParser[models.VersionType] {
    val targetNamespace: Option[String] = Some("http://xuse.sourceforge.net")
    
    override def typeName: Option[String] = Some("versionType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[models.VersionType] =
      phrase((scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "revision")) ~ 
      (scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "author")) ~ 
      (scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "change-date")) ~ 
      (scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "description")) ~ 
      rep(any(_.namespace != Some("http://xuse.sourceforge.net"))) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      models.VersionType(scalaxb.fromXML[Double](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String](p2, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String](p3, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[models.DescriptionType](p4, scalaxb.ElemName(node) :: stack),
        p5.toSeq map { scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) })
    
    override def writesAttribute(__obj: models.VersionType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: models.VersionType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[Double](__obj.revision, Some("http://xuse.sourceforge.net"), Some("revision"), __scope, false),
        scalaxb.toXML[String](__obj.author, Some("http://xuse.sourceforge.net"), Some("author"), __scope, false),
        scalaxb.toXML[String](__obj.changeu45date, Some("http://xuse.sourceforge.net"), Some("change-date"), __scope, false),
        scalaxb.toXML[models.DescriptionType](__obj.description, Some("http://xuse.sourceforge.net"), Some("description"), __scope, false),
        __obj.any flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, true) })

  }

  trait DefaultModelsRequirementu45refTypeFormat extends scalaxb.XMLFormat[models.Requirementu45refType] with scalaxb.CanWriteChildNodes[models.Requirementu45refType] {
    val targetNamespace: Option[String] = Some("http://xuse.sourceforge.net")
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, models.Requirementu45refType] = seq match {
      case node: scala.xml.Node => Right(models.Requirementu45refType(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String]((node \ "@refId"), scalaxb.ElemName(node) :: stack)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: models.Requirementu45refType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "refId", __obj.refId.toString, attr)
      attr
    }

    def writesChildNodes(__obj: models.Requirementu45refType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  def buildModelsStereotypeFormat = new DefaultModelsStereotypeFormat {}
  trait DefaultModelsStereotypeFormat extends scalaxb.XMLFormat[models.Stereotype] {
    val targetNamespace: Option[String] = Some("http://xuse.sourceforge.net")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, models.Stereotype] = seq match {
      case elem: scala.xml.Elem => Right(models.Stereotype.fromString(elem.text, elem.scope))
      case _ => Right(models.Stereotype.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: models.Stereotype, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, scala.xml.Text(__obj.toString))
  }

  trait DefaultModelsUseu45caseu45refTypeFormat extends scalaxb.XMLFormat[models.Useu45caseu45refType] with scalaxb.CanWriteChildNodes[models.Useu45caseu45refType] {
    val targetNamespace: Option[String] = Some("http://xuse.sourceforge.net")
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, models.Useu45caseu45refType] = seq match {
      case node: scala.xml.Node => Right(models.Useu45caseu45refType(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String]((node \ "@refId"), scalaxb.ElemName(node) :: stack),
        (node \ "@stereotype").headOption map { scalaxb.fromXML[models.Stereotype](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: models.Useu45caseu45refType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "refId", __obj.refId.toString, attr)
      __obj.stereotype foreach { x => attr = scala.xml.Attribute(null, "stereotype", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: models.Useu45caseu45refType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultModelsReleaseRefTypeFormat extends scalaxb.XMLFormat[models.ReleaseRefType] with scalaxb.CanWriteChildNodes[models.ReleaseRefType] {
    val targetNamespace: Option[String] = Some("http://xuse.sourceforge.net")
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, models.ReleaseRefType] = seq match {
      case node: scala.xml.Node => Right(models.ReleaseRefType(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String]((node \ "@refId"), scalaxb.ElemName(node) :: stack)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: models.ReleaseRefType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "refId", __obj.refId.toString, attr)
      attr
    }

    def writesChildNodes(__obj: models.ReleaseRefType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultModelsRequirementsCollectionTypeFormat extends scalaxb.ElemNameParser[models.RequirementsCollectionType] {
    val targetNamespace: Option[String] = Some("http://xuse.sourceforge.net")
    
    override def typeName: Option[String] = Some("requirementsCollectionType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[models.RequirementsCollectionType] =
      phrase(rep(scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "req-ref")) ~ 
      rep(any(_.namespace != Some("http://xuse.sourceforge.net"))) ^^
      { case p1 ~ p2 =>
      models.RequirementsCollectionType(p1.toSeq map { _.nilOption map { scalaxb.fromXML[models.Requirementu45refType](_, scalaxb.ElemName(node) :: stack) }},
        p2.toSeq map { scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) })
    
    override def writesAttribute(__obj: models.RequirementsCollectionType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: models.RequirementsCollectionType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.requ45ref flatMap { scalaxb.toXML[Option[models.Requirementu45refType]](_, Some("http://xuse.sourceforge.net"), Some("req-ref"), __scope, false) },
        __obj.any flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, true) })

  }

  trait DefaultModelsAnnotationTypeFormat extends scalaxb.ElemNameParser[models.AnnotationType] {
    val targetNamespace: Option[String] = Some("http://xuse.sourceforge.net")
    
    override def typeName: Option[String] = Some("annotationType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[models.AnnotationType] =
      phrase((scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "description")) ~ 
      (scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "author")) ~ 
      (scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "intended-audience")) ~ 
      opt(scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "creation-date")) ~ 
      opt(scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "comments")) ~ 
      rep(any(_.namespace != Some("http://xuse.sourceforge.net"))) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 =>
      models.AnnotationType(scalaxb.fromXML[models.DescriptionType](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String](p2, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[models.AudienceType](p3, scalaxb.ElemName(node) :: stack),
        p4.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p5.headOption map { scalaxb.fromXML[models.CommentsType](_, scalaxb.ElemName(node) :: stack) },
        p6.toSeq map { scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) })
    
    override def writesAttribute(__obj: models.AnnotationType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: models.AnnotationType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[models.DescriptionType](__obj.description, Some("http://xuse.sourceforge.net"), Some("description"), __scope, false),
        scalaxb.toXML[String](__obj.author, Some("http://xuse.sourceforge.net"), Some("author"), __scope, false),
        scalaxb.toXML[models.AudienceType](__obj.intendedu45audience, Some("http://xuse.sourceforge.net"), Some("intended-audience"), __scope, false),
        __obj.creationu45date map { scalaxb.toXML[String](_, Some("http://xuse.sourceforge.net"), Some("creation-date"), __scope, false) } getOrElse {Nil},
        __obj.comments map { scalaxb.toXML[models.CommentsType](_, Some("http://xuse.sourceforge.net"), Some("comments"), __scope, false) } getOrElse {Nil},
        __obj.any flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, true) })

  }

  trait DefaultModelsCommentsTypeFormat extends scalaxb.ElemNameParser[models.CommentsType] {
    val targetNamespace: Option[String] = Some("http://xuse.sourceforge.net")
    
    override def typeName: Option[String] = Some("commentsType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[models.CommentsType] =
      phrase(rep(scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "comment")) ~ 
      rep(any(_.namespace != Some("http://xuse.sourceforge.net"))) ^^
      { case p1 ~ p2 =>
      models.CommentsType(p1.toSeq map { scalaxb.fromXML[models.CommentType](_, scalaxb.ElemName(node) :: stack) },
        p2.toSeq map { scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: models.CommentsType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.comment flatMap { scalaxb.toXML[models.CommentType](_, Some("http://xuse.sourceforge.net"), Some("comment"), __scope, false) },
        __obj.any flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, true) })

  }

  trait DefaultModelsCommentTypeFormat extends scalaxb.ElemNameParser[models.CommentType] {
    val targetNamespace: Option[String] = Some("http://xuse.sourceforge.net")
    
    override def typeName: Option[String] = Some("commentType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[models.CommentType] =
      phrase(opt(scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "description")) ~ 
      opt(scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "comment-author")) ~ 
      opt(scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "comment-date")) ~ 
      rep(any(_.namespace != Some("http://xuse.sourceforge.net"))) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      models.CommentType(p1.headOption map { scalaxb.fromXML[models.DescriptionType](_, scalaxb.ElemName(node) :: stack) },
        p2.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p3.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p4.toSeq map { scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack) }) })
    
    def writesChildNodes(__obj: models.CommentType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.description map { scalaxb.toXML[models.DescriptionType](_, Some("http://xuse.sourceforge.net"), Some("description"), __scope, false) } getOrElse {Nil},
        __obj.commentu45author map { scalaxb.toXML[String](_, Some("http://xuse.sourceforge.net"), Some("comment-author"), __scope, false) } getOrElse {Nil},
        __obj.commentu45date map { scalaxb.toXML[String](_, Some("http://xuse.sourceforge.net"), Some("comment-date"), __scope, false) } getOrElse {Nil},
        __obj.any flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, true) })

  }

  trait DefaultModelsStakeholderTypeFormat extends scalaxb.ElemNameParser[models.StakeholderType] {
    val targetNamespace: Option[String] = Some("http://xuse.sourceforge.net")
    
    override def typeName: Option[String] = Some("stakeholderType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[models.StakeholderType] =
      phrase((scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "title")) ~ 
      (scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "description")) ~ 
      (scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "role")) ~ 
      rep(scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "representative")) ~ 
      rep(any(_.namespace != Some("http://xuse.sourceforge.net"))) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 =>
      models.StakeholderType(scalaxb.fromXML[models.TitleType](p1, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[models.DescriptionType](p2, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String](p3, scalaxb.ElemName(node) :: stack),
        p4.toSeq map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p5.toSeq map { scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[String]((node \ "@id"), scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) })
    
    override def writesAttribute(__obj: models.StakeholderType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "id", __obj.id.toString, attr)
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: models.StakeholderType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[models.TitleType](__obj.title, Some("http://xuse.sourceforge.net"), Some("title"), __scope, false),
        scalaxb.toXML[models.DescriptionType](__obj.description, Some("http://xuse.sourceforge.net"), Some("description"), __scope, false),
        scalaxb.toXML[String](__obj.role, Some("http://xuse.sourceforge.net"), Some("role"), __scope, false),
        __obj.representative flatMap { scalaxb.toXML[String](_, Some("http://xuse.sourceforge.net"), Some("representative"), __scope, false) },
        __obj.any flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, true) })

  }


/** Group of all the different reference elements that can be created within Xuse
*/
  trait ModelsReferenceTypeu45groupGroupFormat extends scalaxb.AnyElemNameParser {
    def parseReferenceTypeu45groupGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.DataRecord[Option[models.ReferenceTypeu45groupOption]]] =
      (((scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "uc-ref")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), x.nilOption map {scalaxb.fromXML[models.Useu45caseu45refType](_, scalaxb.ElemName(node) :: stack)}))) | 
      ((scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "req-ref")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), x.nilOption map {scalaxb.fromXML[models.Requirementu45refType](_, scalaxb.ElemName(node) :: stack)}))) | 
      ((scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "actor-ref")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), x.nilOption map {scalaxb.fromXML[models.Actoru45refType](_, scalaxb.ElemName(node) :: stack)}))) | 
      ((scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "stakeholder-ref")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), x.nilOption map {scalaxb.fromXML[models.Stakeholderu45refType](_, scalaxb.ElemName(node) :: stack)}))))
  
    def parseReferenceTypeu45groupGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Option[models.ReferenceTypeu45groupOption]]] =
      (((scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "uc-ref")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), x.nilOption map {scalaxb.fromXML[models.Useu45caseu45refType](_, scalaxb.ElemName(node) :: stack)}))) | 
      ((scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "req-ref")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), x.nilOption map {scalaxb.fromXML[models.Requirementu45refType](_, scalaxb.ElemName(node) :: stack)}))) | 
      ((scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "actor-ref")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), x.nilOption map {scalaxb.fromXML[models.Actoru45refType](_, scalaxb.ElemName(node) :: stack)}))) | 
      ((scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "stakeholder-ref")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), x.nilOption map {scalaxb.fromXML[models.Stakeholderu45refType](_, scalaxb.ElemName(node) :: stack)}))))
    
    def parsemixedReferenceTypeu45groupGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      (((((scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "uc-ref")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), x.nilOption map {scalaxb.fromXML[models.Useu45caseu45refType](_, scalaxb.ElemName(node) :: stack)}))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "req-ref")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), x.nilOption map {scalaxb.fromXML[models.Requirementu45refType](_, scalaxb.ElemName(node) :: stack)}))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "actor-ref")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[models.Actoru45refType](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }) ||| 
      ((((scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "stakeholder-ref")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), x.nilOption map {scalaxb.fromXML[models.Stakeholderu45refType](_, scalaxb.ElemName(node) :: stack)}))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) }))
  }

  trait DefaultModelsDictionaryFormat extends scalaxb.ElemNameParser[models.Dictionary] {
    val targetNamespace: Option[String] = Some("http://xuse.sourceforge.net")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[models.Dictionary] =
      phrase(rep(scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "entry")) ~ 
      rep(any(_.namespace != Some("http://xuse.sourceforge.net"))) ^^
      { case p1 ~ p2 =>
      models.Dictionary(p1.toSeq map { scalaxb.fromXML[models.DictionaryEntryType](_, scalaxb.ElemName(node) :: stack) },
        p2.toSeq map { scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[String](scala.xml.Text("1.0"), scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "model-version" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) })
    
    override def writesAttribute(__obj: models.Dictionary, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "model-version", __obj.modelu45version.toString, attr)
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: models.Dictionary, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.entry flatMap { scalaxb.toXML[models.DictionaryEntryType](_, Some("http://xuse.sourceforge.net"), Some("entry"), __scope, false) },
        __obj.any flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, true) })

  }

  trait DefaultModelsDictionaryEntryTypeFormat extends scalaxb.ElemNameParser[models.DictionaryEntryType] {
    val targetNamespace: Option[String] = Some("http://xuse.sourceforge.net")
    
    override def typeName: Option[String] = Some("dictionaryEntryType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[models.DictionaryEntryType] =
      phrase(rep(scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "value")) ^^
      { case p1 =>
      models.DictionaryEntryType(p1.toSeq map { scalaxb.fromXML[models.ValueType](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[String]((node \ "@key"), scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "key" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) })
    
    override def writesAttribute(__obj: models.DictionaryEntryType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "key", __obj.key.toString, attr)
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: models.DictionaryEntryType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.value flatMap { scalaxb.toXML[models.ValueType](_, Some("http://xuse.sourceforge.net"), Some("value"), __scope, false) })

  }

  trait DefaultModelsValueTypeFormat extends scalaxb.XMLFormat[models.ValueType] with scalaxb.CanWriteChildNodes[models.ValueType] {
    val targetNamespace: Option[String] = Some("http://xuse.sourceforge.net")
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, models.ValueType] = seq match {
      case node: scala.xml.Node => Right(models.ValueType(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        (node \ "@{http://www.w3.org/XML/1998/namespace}lang").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.PrefixedAttribute(pre, key, value, _) if pre == elem.scope.getPrefix("http://www.w3.org/XML/1998/namespace") &&
                key == "lang" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: models.ValueType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.xmllang foreach { x => attr = scala.xml.Attribute(__scope.getPrefix("http://www.w3.org/XML/1998/namespace"), "lang", x.toString, attr) }
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: models.ValueType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultModelsGlossaryFormat extends scalaxb.ElemNameParser[models.Glossary] {
    val targetNamespace: Option[String] = Some("http://xuse.sourceforge.net")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[models.Glossary] =
      phrase(rep(scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "entry")) ~ 
      rep(any(_.namespace != Some("http://xuse.sourceforge.net"))) ^^
      { case p1 ~ p2 =>
      models.Glossary(p1.toSeq map { scalaxb.fromXML[models.GlossaryEntryType](_, scalaxb.ElemName(node) :: stack) },
        p2.toSeq map { scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[String](scala.xml.Text("1.0"), scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "model-version" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) })
    
    override def writesAttribute(__obj: models.Glossary, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "model-version", __obj.modelu45version.toString, attr)
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: models.Glossary, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.entry flatMap { scalaxb.toXML[models.GlossaryEntryType](_, Some("http://xuse.sourceforge.net"), Some("entry"), __scope, false) },
        __obj.any flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, true) })

  }

  trait DefaultModelsGlossaryEntryTypeFormat extends scalaxb.ElemNameParser[models.GlossaryEntryType] {
    val targetNamespace: Option[String] = Some("http://xuse.sourceforge.net")
    
    override def typeName: Option[String] = Some("glossaryEntryType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[models.GlossaryEntryType] =
      phrase((scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "title")) ~ 
      opt(scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "abbreviation")) ~ 
      (scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "description")) ~ 
      rep(any(_.namespace != Some("http://xuse.sourceforge.net"))) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      models.GlossaryEntryType(scalaxb.fromXML[models.TitleType](p1, scalaxb.ElemName(node) :: stack),
        p2.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[models.NarrativeType](p3, scalaxb.ElemName(node) :: stack),
        p4.toSeq map { scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) })
    
    override def writesAttribute(__obj: models.GlossaryEntryType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: models.GlossaryEntryType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[models.TitleType](__obj.title, Some("http://xuse.sourceforge.net"), Some("title"), __scope, false),
        __obj.abbreviation map { scalaxb.toXML[String](_, Some("http://xuse.sourceforge.net"), Some("abbreviation"), __scope, false) } getOrElse {Nil},
        scalaxb.toXML[models.NarrativeType](__obj.description, Some("http://xuse.sourceforge.net"), Some("description"), __scope, false),
        __obj.any flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, true) })

  }


  trait ModelsReplacementu45textu45elementsu45groupGroupFormat extends scalaxb.AnyElemNameParser {
    def parseReplacementu45textu45elementsu45groupGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[scalaxb.DataRecord[Any]] =
      (((any(_ => true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))) | 
      ((any(_ => true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))) | 
      ((any(_ => true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))) | 
      ((any(_ => true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))) | 
      ((any(_ => true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))) | 
      ((any(_ => true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))) | 
      ((any(_ => true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))) | 
      ((any(_ => true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))) | 
      ((any(_ => true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))) | 
      ((any(_ => true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))))
  
    def parseReplacementu45textu45elementsu45groupGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName], wrap: Boolean): Parser[scalaxb.DataRecord[Any]] =
      (((any(_ => true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))) | 
      ((any(_ => true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))) | 
      ((any(_ => true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))) | 
      ((any(_ => true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))) | 
      ((any(_ => true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))) | 
      ((any(_ => true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))) | 
      ((any(_ => true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))) | 
      ((any(_ => true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))) | 
      ((any(_ => true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))) | 
      ((any(_ => true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))))
    
    def parsemixedReplacementu45textu45elementsu45groupGroup(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[Seq[scalaxb.DataRecord[Any]]] =
      ((((((any(_ => true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack))) ~ 
      optTextRecord) ^^ 
      { case p1 ~ p2 => Seq.concat(Seq(p1), p2.toList) }) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(p1,
        p2.toList) }) ||| 
      (((((any(_ => true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack))) ~ 
      optTextRecord) ^^ 
      { case p1 ~ p2 => Seq.concat(Seq(p1), p2.toList) }) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(p1,
        p2.toList) }) ||| 
      (((((any(_ => true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack))) ~ 
      optTextRecord) ^^ 
      { case p1 ~ p2 => Seq.concat(Seq(p1), p2.toList) }) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(p1,
        p2.toList) }) ||| 
      (((((any(_ => true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack))) ~ 
      optTextRecord) ^^ 
      { case p1 ~ p2 => Seq.concat(Seq(p1), p2.toList) }) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(p1,
        p2.toList) }) ||| 
      (((((any(_ => true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack))) ~ 
      optTextRecord) ^^ 
      { case p1 ~ p2 => Seq.concat(Seq(p1), p2.toList) }) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(p1,
        p2.toList) }) ||| 
      (((((any(_ => true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack))) ~ 
      optTextRecord) ^^ 
      { case p1 ~ p2 => Seq.concat(Seq(p1), p2.toList) }) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(p1,
        p2.toList) }) ||| 
      (((((any(_ => true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack))) ~ 
      optTextRecord) ^^ 
      { case p1 ~ p2 => Seq.concat(Seq(p1), p2.toList) }) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(p1,
        p2.toList) }) ||| 
      (((((any(_ => true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack))) ~ 
      optTextRecord) ^^ 
      { case p1 ~ p2 => Seq.concat(Seq(p1), p2.toList) }) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(p1,
        p2.toList) }) ||| 
      (((((any(_ => true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack))) ~ 
      optTextRecord) ^^ 
      { case p1 ~ p2 => Seq.concat(Seq(p1), p2.toList) }) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(p1,
        p2.toList) }) ||| 
      (((((any(_ => true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack))) ~ 
      optTextRecord) ^^ 
      { case p1 ~ p2 => Seq.concat(Seq(p1), p2.toList) }) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(p1,
        p2.toList) }))
  }

  trait DefaultModelsRequirementsFormat extends scalaxb.ElemNameParser[models.Requirements] {
    val targetNamespace: Option[String] = Some("http://xuse.sourceforge.net")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[models.Requirements] =
      phrase(rep(scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "req")) ~ 
      rep(any(_.namespace != Some("http://xuse.sourceforge.net"))) ^^
      { case p1 ~ p2 =>
      models.Requirements(p1.toSeq map { scalaxb.fromXML[models.RequirementType](_, scalaxb.ElemName(node) :: stack) },
        p2.toSeq map { scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[String](scala.xml.Text("1.0"), scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "model-version" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) })
    
    override def writesAttribute(__obj: models.Requirements, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "model-version", __obj.modelu45version.toString, attr)
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: models.Requirements, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.req flatMap { scalaxb.toXML[models.RequirementType](_, Some("http://xuse.sourceforge.net"), Some("req"), __scope, false) },
        __obj.any flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, true) })

  }

  trait DefaultModelsStakeholdersFormat extends scalaxb.ElemNameParser[models.Stakeholders] {
    val targetNamespace: Option[String] = Some("http://xuse.sourceforge.net")
    
    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[models.Stakeholders] =
      phrase(rep(scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "stakeholder")) ~ 
      rep(any(_.namespace != Some("http://xuse.sourceforge.net"))) ^^
      { case p1 ~ p2 =>
      models.Stakeholders(p1.toSeq map { scalaxb.fromXML[models.StakeholderType](_, scalaxb.ElemName(node) :: stack) },
        p2.toSeq map { scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[String](scala.xml.Text("1.0"), scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "model-version" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) })
    
    override def writesAttribute(__obj: models.Stakeholders, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "model-version", __obj.modelu45version.toString, attr)
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: models.Stakeholders, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.stakeholder flatMap { scalaxb.toXML[models.StakeholderType](_, Some("http://xuse.sourceforge.net"), Some("stakeholder"), __scope, false) },
        __obj.any flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, true) })

  }

  trait DefaultModelsTraceu45reportTypeFormat extends scalaxb.ElemNameParser[models.Traceu45reportType] {
    val targetNamespace: Option[String] = Some("http://www.xml-solutions.com/xuse/trace-report")
    
    override def typeName: Option[String] = Some("trace-reportType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[models.Traceu45reportType] =
      phrase(rep(scalaxb.ElemName(Some("http://www.xml-solutions.com/xuse/trace-report"), "artefact")) ^^
      { case p1 =>
      models.Traceu45reportType(p1.toSeq map { scalaxb.fromXML[models.ArtefactType](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[String]((node \ "@created"), scalaxb.ElemName(node) :: stack),
        (node \ "@base-uri").headOption map { scalaxb.fromXML[java.net.URI](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[String]((node \ "@base-id"), scalaxb.ElemName(node) :: stack)) })
    
    override def writesAttribute(__obj: models.Traceu45reportType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "created", __obj.created.toString, attr)
      __obj.baseu45uri foreach { x => attr = scala.xml.Attribute(null, "base-uri", x.toString, attr) }
      attr = scala.xml.Attribute(null, "base-id", __obj.baseu45id.toString, attr)
      attr
    }

    def writesChildNodes(__obj: models.Traceu45reportType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      (__obj.artefact flatMap { scalaxb.toXML[models.ArtefactType](_, Some("http://www.xml-solutions.com/xuse/trace-report"), Some("artefact"), __scope, false) })

  }

  def buildModelsClassFormat = new DefaultModelsClassFormat {}
  trait DefaultModelsClassFormat extends scalaxb.XMLFormat[models.Class] {
    val targetNamespace: Option[String] = Some("http://www.xml-solutions.com/xuse/trace-report")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, models.Class] = seq match {
      case elem: scala.xml.Elem => Right(models.Class.fromString(elem.text, elem.scope))
      case _ => Right(models.Class.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: models.Class, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, scala.xml.Text(__obj.toString))
  }

  trait DefaultModelsTraceu45toFormat extends scalaxb.XMLFormat[models.Traceu45to] with scalaxb.CanWriteChildNodes[models.Traceu45to] {
    val targetNamespace: Option[String] = Some("http://www.xml-solutions.com/xuse/trace-report")
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, models.Traceu45to] = seq match {
      case node: scala.xml.Node => Right(models.Traceu45to(scalaxb.fromXML[String](node, scalaxb.ElemName(node) :: stack),
        (node \ "@class").headOption map { scalaxb.fromXML[models.Class](_, scalaxb.ElemName(node) :: stack) }))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: models.Traceu45to, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.classValue foreach { x => attr = scala.xml.Attribute(null, "class", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: models.Traceu45to, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq(scala.xml.Text(__obj.value.toString))


  }

  trait DefaultModelsArtefactTypeFormat extends scalaxb.ElemNameParser[models.ArtefactType] {
    val targetNamespace: Option[String] = Some("http://www.xml-solutions.com/xuse/trace-report")
    
    override def typeName: Option[String] = Some("artefactType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[models.ArtefactType] =
      phrase((scalaxb.ElemName(Some("http://www.xml-solutions.com/xuse/trace-report"), "id")) ~ 
      opt(scalaxb.ElemName(Some("http://www.xml-solutions.com/xuse/trace-report"), "location")) ~ 
      rep(scalaxb.ElemName(Some("http://www.xml-solutions.com/xuse/trace-report"), "trace-to")) ~ 
      opt(scalaxb.ElemName(Some("http://www.xml-solutions.com/xuse/trace-report"), "status")) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      models.ArtefactType(scalaxb.fromXML[String](p1, scalaxb.ElemName(node) :: stack),
        p2.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        p3.toSeq map { scalaxb.fromXML[models.Traceu45to](_, scalaxb.ElemName(node) :: stack) },
        p4.headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[String]((node \ "@type"), scalaxb.ElemName(node) :: stack),
        (node \ "@uri").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) }) })
    
    override def writesAttribute(__obj: models.ArtefactType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "type", __obj.typeValue.toString, attr)
      __obj.uri foreach { x => attr = scala.xml.Attribute(null, "uri", x.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: models.ArtefactType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(scalaxb.toXML[String](__obj.id, Some("http://www.xml-solutions.com/xuse/trace-report"), Some("id"), __scope, false),
        __obj.location map { scalaxb.toXML[String](_, Some("http://www.xml-solutions.com/xuse/trace-report"), Some("location"), __scope, false) } getOrElse {Nil},
        __obj.traceu45to flatMap { scalaxb.toXML[models.Traceu45to](_, Some("http://www.xml-solutions.com/xuse/trace-report"), Some("trace-to"), __scope, false) },
        __obj.status map { scalaxb.toXML[String](_, Some("http://www.xml-solutions.com/xuse/trace-report"), Some("status"), __scope, false) } getOrElse {Nil})

  }

  def buildModelsBuiltu45inu45artefactu45classifiersTypeFormat = new DefaultModelsBuiltu45inu45artefactu45classifiersTypeFormat {}
  trait DefaultModelsBuiltu45inu45artefactu45classifiersTypeFormat extends scalaxb.XMLFormat[models.Builtu45inu45artefactu45classifiersType] {
    val targetNamespace: Option[String] = Some("http://www.xml-solutions.com/xuse/trace-report")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, models.Builtu45inu45artefactu45classifiersType] = seq match {
      case elem: scala.xml.Elem => Right(models.Builtu45inu45artefactu45classifiersType.fromString(elem.text, elem.scope))
      case _ => Right(models.Builtu45inu45artefactu45classifiersType.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: models.Builtu45inu45artefactu45classifiersType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, scala.xml.Text(__obj.toString))
  }

  trait DefaultModelsUseu45caseTypeFormat extends scalaxb.ElemNameParser[models.Useu45caseType] {
    val targetNamespace: Option[String] = Some("http://xuse.sourceforge.net")
    
    override def typeName: Option[String] = Some("use-caseType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[models.Useu45caseType] =
      phrase(rep(scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "annotation")) ~ 
      (scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "description")) ~ 
      (scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "document-history")) ~ 
      (scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "use-case-properties")) ~ 
      (scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "main-flow")) ~ 
      opt(scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "alternate-flows")) ~ 
      opt(scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "exception-flows")) ~ 
      opt(scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "business-rules")) ~ 
      rep(any(_.namespace != Some("http://xuse.sourceforge.net"))) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 =>
      models.Useu45caseType(p1.toSeq map { scalaxb.fromXML[models.AnnotationType](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[models.DescriptionType](p2, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[models.Documentu45historyType](p3, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[models.Useu45caseu45propertiesType](p4, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[models.MainSequenceType](p5, scalaxb.ElemName(node) :: stack),
        p6.headOption map { scalaxb.fromXML[models.Alternateu45flowsType](_, scalaxb.ElemName(node) :: stack) },
        p7.headOption map { scalaxb.fromXML[models.Exceptionu45flowsType](_, scalaxb.ElemName(node) :: stack) },
        p8.headOption map { scalaxb.fromXML[models.RequirementsCollectionType](_, scalaxb.ElemName(node) :: stack) },
        p9.toSeq map { scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[String]((node \ "@id"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String]((node \ "@name"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String](scala.xml.Text("1.0"), scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "name" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "model-version" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) })
    
    override def writesAttribute(__obj: models.Useu45caseType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "id", __obj.id.toString, attr)
      attr = scala.xml.Attribute(null, "name", __obj.name.toString, attr)
      attr = scala.xml.Attribute(null, "model-version", __obj.modelu45version.toString, attr)
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: models.Useu45caseType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[models.AnnotationType](_, Some("http://xuse.sourceforge.net"), Some("annotation"), __scope, false) },
        scalaxb.toXML[models.DescriptionType](__obj.description, Some("http://xuse.sourceforge.net"), Some("description"), __scope, false),
        scalaxb.toXML[models.Documentu45historyType](__obj.documentu45history, Some("http://xuse.sourceforge.net"), Some("document-history"), __scope, false),
        scalaxb.toXML[models.Useu45caseu45propertiesType](__obj.useu45caseu45properties, Some("http://xuse.sourceforge.net"), Some("use-case-properties"), __scope, false),
        scalaxb.toXML[models.MainSequenceType](__obj.mainu45flow, Some("http://xuse.sourceforge.net"), Some("main-flow"), __scope, false),
        __obj.alternateu45flows map { scalaxb.toXML[models.Alternateu45flowsType](_, Some("http://xuse.sourceforge.net"), Some("alternate-flows"), __scope, false) } getOrElse {Nil},
        __obj.exceptionu45flows map { scalaxb.toXML[models.Exceptionu45flowsType](_, Some("http://xuse.sourceforge.net"), Some("exception-flows"), __scope, false) } getOrElse {Nil},
        __obj.businessu45rules map { scalaxb.toXML[models.RequirementsCollectionType](_, Some("http://xuse.sourceforge.net"), Some("business-rules"), __scope, false) } getOrElse {Nil},
        __obj.any flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, true) })

  }

  trait DefaultModelsUseu45caseu45propertiesTypeFormat extends scalaxb.ElemNameParser[models.Useu45caseu45propertiesType] {
    val targetNamespace: Option[String] = Some("http://xuse.sourceforge.net")
    
    override def typeName: Option[String] = Some("use-case-propertiesType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[models.Useu45caseu45propertiesType] =
      phrase(rep(scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "annotation")) ~ 
      (scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "trigger")) ~ 
      (scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "goal")) ~ 
      rep(scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "primary-actor")) ~ 
      rep(scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "secondary-actor")) ~ 
      (scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "pre-requisites")) ~ 
      (scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "success-outcome")) ~ 
      (scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "failure-outcome")) ~ 
      (scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "priority")) ~ 
      (scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "complexity")) ~ 
      rep(scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "taxonomy")) ~ 
      rep(any(_.namespace != Some("http://xuse.sourceforge.net"))) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 ~ p7 ~ p8 ~ p9 ~ p10 ~ p11 ~ p12 =>
      models.Useu45caseu45propertiesType(p1.toSeq map { scalaxb.fromXML[models.AnnotationType](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[models.DescriptionType](p2, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[models.DescriptionType](p3, scalaxb.ElemName(node) :: stack),
        p4.toSeq map { scalaxb.fromXML[models.Actoru45refType](_, scalaxb.ElemName(node) :: stack) },
        p5.toSeq map { scalaxb.fromXML[models.Actoru45refType](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[models.DescriptionType](p6, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[models.DescriptionType](p7, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[models.DescriptionType](p8, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String](p9, scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[BigInt](p10, scalaxb.ElemName(node) :: stack),
        p11.toSeq map { scalaxb.fromXML[models.TaxonomyType](_, scalaxb.ElemName(node) :: stack) },
        p12.toSeq map { scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) })
    
    override def writesAttribute(__obj: models.Useu45caseu45propertiesType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: models.Useu45caseu45propertiesType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[models.AnnotationType](_, Some("http://xuse.sourceforge.net"), Some("annotation"), __scope, false) },
        scalaxb.toXML[models.DescriptionType](__obj.trigger, Some("http://xuse.sourceforge.net"), Some("trigger"), __scope, false),
        scalaxb.toXML[models.DescriptionType](__obj.goal, Some("http://xuse.sourceforge.net"), Some("goal"), __scope, false),
        __obj.primaryu45actor flatMap { scalaxb.toXML[models.Actoru45refType](_, Some("http://xuse.sourceforge.net"), Some("primary-actor"), __scope, false) },
        __obj.secondaryu45actor flatMap { scalaxb.toXML[models.Actoru45refType](_, Some("http://xuse.sourceforge.net"), Some("secondary-actor"), __scope, false) },
        scalaxb.toXML[models.DescriptionType](__obj.preu45requisites, Some("http://xuse.sourceforge.net"), Some("pre-requisites"), __scope, false),
        scalaxb.toXML[models.DescriptionType](__obj.successu45outcome, Some("http://xuse.sourceforge.net"), Some("success-outcome"), __scope, false),
        scalaxb.toXML[models.DescriptionType](__obj.failureu45outcome, Some("http://xuse.sourceforge.net"), Some("failure-outcome"), __scope, false),
        scalaxb.toXML[String](__obj.priority, Some("http://xuse.sourceforge.net"), Some("priority"), __scope, false),
        scalaxb.toXML[BigInt](__obj.complexity, Some("http://xuse.sourceforge.net"), Some("complexity"), __scope, false),
        __obj.taxonomy flatMap { scalaxb.toXML[models.TaxonomyType](_, Some("http://xuse.sourceforge.net"), Some("taxonomy"), __scope, false) },
        __obj.any flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, true) })

  }

  trait DefaultModelsSequenceTypableFormat extends scalaxb.XMLFormat[models.SequenceTypable] {
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, models.SequenceTypable] = seq match {
      case node: scala.xml.Node =>     
        scalaxb.Helper.instanceType(node) match {
          case (Some("http://xuse.sourceforge.net"), Some("mainSequenceType")) => Right(scalaxb.fromXML[models.MainSequenceType](node, stack))
          case (Some("http://xuse.sourceforge.net"), Some("alternateSequenceType")) => Right(scalaxb.fromXML[models.AlternateSequenceType](node, stack))
          case _ => Right(scalaxb.fromXML[models.SequenceType](node, stack))
        }
      case _ => Left("reads failed: seq must be scala.xml.Node")  
    }
    
    def writes(__obj: models.SequenceTypable, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq = __obj match {
      case x: models.MainSequenceType => scalaxb.toXML[models.MainSequenceType](x, __namespace, __elementLabel, __scope, true)
      case x: models.AlternateSequenceType => scalaxb.toXML[models.AlternateSequenceType](x, __namespace, __elementLabel, __scope, true)
      case x: models.SequenceType => scalaxb.toXML[models.SequenceType](x, __namespace, __elementLabel, __scope, false)
    }
  }

  trait DefaultModelsSequenceTypeFormat extends scalaxb.ElemNameParser[models.SequenceType] {
    val targetNamespace: Option[String] = Some("http://xuse.sourceforge.net")
    
    override def typeName: Option[String] = Some("sequenceType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[models.SequenceType] =
      phrase(rep(scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "annotation")) ~ 
      rep(scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "step")) ~ 
      rep(any(_.namespace != Some("http://xuse.sourceforge.net"))) ^^
      { case p1 ~ p2 ~ p3 =>
      models.SequenceType(p1.toSeq map { scalaxb.fromXML[models.AnnotationType](_, scalaxb.ElemName(node) :: stack) },
        p2.toSeq map { scalaxb.fromXML[models.StepType](_, scalaxb.ElemName(node) :: stack) },
        p3.toSeq map { scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) })
    
    override def writesAttribute(__obj: models.SequenceType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: models.SequenceType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[models.AnnotationType](_, Some("http://xuse.sourceforge.net"), Some("annotation"), __scope, false) },
        __obj.step flatMap { scalaxb.toXML[models.StepType](_, Some("http://xuse.sourceforge.net"), Some("step"), __scope, false) },
        __obj.any flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, true) })

  }

  trait DefaultModelsMainSequenceTypeFormat extends scalaxb.ElemNameParser[models.MainSequenceType] {
    val targetNamespace: Option[String] = Some("http://xuse.sourceforge.net")
    
    override def typeName: Option[String] = Some("mainSequenceType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[models.MainSequenceType] =
      phrase(rep(scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "annotation")) ~ 
      rep(scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "step")) ~ 
      rep(any(_.namespace != Some("http://xuse.sourceforge.net"))) ~ 
      (any(_ => true)) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      models.MainSequenceType(p1.toSeq map { scalaxb.fromXML[models.AnnotationType](_, scalaxb.ElemName(node) :: stack) },
        p2.toSeq map { scalaxb.fromXML[models.StepType](_, scalaxb.ElemName(node) :: stack) },
        p3.toSeq map { scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[scalaxb.DataRecord[Any]](p4, scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) })
    
    override def writesAttribute(__obj: models.MainSequenceType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: models.MainSequenceType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[models.AnnotationType](_, Some("http://xuse.sourceforge.net"), Some("annotation"), __scope, false) },
        __obj.step flatMap { scalaxb.toXML[models.StepType](_, Some("http://xuse.sourceforge.net"), Some("step"), __scope, false) },
        __obj.any flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, true) },
        Some(__obj.end) map {x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, true)} get)

  }

  trait DefaultModelsRejoinFormat extends scalaxb.XMLFormat[models.Rejoin] with scalaxb.CanWriteChildNodes[models.Rejoin] {
    val targetNamespace: Option[String] = Some("http://xuse.sourceforge.net")
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, models.Rejoin] = seq match {
      case node: scala.xml.Node => Right(models.Rejoin(scalaxb.fromXML[String]((node \ "@at-step"), scalaxb.ElemName(node) :: stack)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: models.Rejoin, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "at-step", __obj.atu45step.toString, attr)
      attr
    }

    def writesChildNodes(__obj: models.Rejoin, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultModelsAlternateSequenceTypeFormat extends scalaxb.ElemNameParser[models.AlternateSequenceType] {
    val targetNamespace: Option[String] = Some("http://xuse.sourceforge.net")
    
    override def typeName: Option[String] = Some("alternateSequenceType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[models.AlternateSequenceType] =
      phrase(rep(scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "annotation")) ~ 
      rep(scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "step")) ~ 
      rep(any(_.namespace != Some("http://xuse.sourceforge.net"))) ~ 
      (((any(_ => true) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack)))) | 
      ((scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "rejoin")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[models.Rejoin](x, scalaxb.ElemName(node) :: stack))))) ^^
      { case p1 ~ p2 ~ p3 ~ p4 =>
      models.AlternateSequenceType(p1.toSeq map { scalaxb.fromXML[models.AnnotationType](_, scalaxb.ElemName(node) :: stack) },
        p2.toSeq map { scalaxb.fromXML[models.StepType](_, scalaxb.ElemName(node) :: stack) },
        p3.toSeq map { scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack) },
        p4,
        scalaxb.fromXML[String]((node \ "@id"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String]((node \ "@title"), scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "title" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) })
    
    override def writesAttribute(__obj: models.AlternateSequenceType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "id", __obj.id.toString, attr)
      attr = scala.xml.Attribute(null, "title", __obj.title.toString, attr)
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: models.AlternateSequenceType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[models.AnnotationType](_, Some("http://xuse.sourceforge.net"), Some("annotation"), __scope, false) },
        __obj.step flatMap { scalaxb.toXML[models.StepType](_, Some("http://xuse.sourceforge.net"), Some("step"), __scope, false) },
        __obj.any flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, true) },
        Some(__obj.alternatesequencetypeoption) map {x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false)} get)

  }

  trait DefaultModelsStepTypeFormat extends scalaxb.ElemNameParser[models.StepType] {
    val targetNamespace: Option[String] = Some("http://xuse.sourceforge.net")
    
    override def typeName: Option[String] = Some("stepType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[models.StepType] =
      phrase(rep(scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "annotation")) ~ 
      (scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "description")) ~ 
      opt(scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "proposed-release")) ~ 
      rep(scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "ref-alternate-flow")) ~ 
      rep(scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "ref-exception-flow")) ~ 
      rep(any(_.namespace != Some("http://xuse.sourceforge.net"))) ^^
      { case p1 ~ p2 ~ p3 ~ p4 ~ p5 ~ p6 =>
      models.StepType(p1.toSeq map { scalaxb.fromXML[models.AnnotationType](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[models.DescriptionType](p2, scalaxb.ElemName(node) :: stack),
        p3.headOption map { scalaxb.fromXML[models.ReleaseRefType](_, scalaxb.ElemName(node) :: stack) },
        p4.toSeq map { scalaxb.fromXML[models.Refu45alternateu45flowsType](_, scalaxb.ElemName(node) :: stack) },
        p5.toSeq map { scalaxb.fromXML[models.Refu45alternateu45flowsType](_, scalaxb.ElemName(node) :: stack) },
        p6.toSeq map { scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack) },
        scalaxb.fromXML[String]((node \ "@step-id"), scalaxb.ElemName(node) :: stack),
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "step-id" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) })
    
    override def writesAttribute(__obj: models.StepType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "step-id", __obj.stepu45id.toString, attr)
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: models.StepType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.annotation flatMap { scalaxb.toXML[models.AnnotationType](_, Some("http://xuse.sourceforge.net"), Some("annotation"), __scope, false) },
        scalaxb.toXML[models.DescriptionType](__obj.description, Some("http://xuse.sourceforge.net"), Some("description"), __scope, false),
        __obj.proposedu45release map { scalaxb.toXML[models.ReleaseRefType](_, Some("http://xuse.sourceforge.net"), Some("proposed-release"), __scope, false) } getOrElse {Nil},
        __obj.refu45alternateu45flow flatMap { scalaxb.toXML[models.Refu45alternateu45flowsType](_, Some("http://xuse.sourceforge.net"), Some("ref-alternate-flow"), __scope, false) },
        __obj.refu45exceptionu45flow flatMap { scalaxb.toXML[models.Refu45alternateu45flowsType](_, Some("http://xuse.sourceforge.net"), Some("ref-exception-flow"), __scope, false) },
        __obj.any flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, true) })

  }

  trait DefaultModelsAlternateu45flowsTypeFormat extends scalaxb.ElemNameParser[models.Alternateu45flowsType] {
    val targetNamespace: Option[String] = Some("http://xuse.sourceforge.net")
    
    override def typeName: Option[String] = Some("alternate-flowsType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[models.Alternateu45flowsType] =
      phrase(rep(scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "alternate-flow")) ~ 
      rep(any(_.namespace != Some("http://xuse.sourceforge.net"))) ^^
      { case p1 ~ p2 =>
      models.Alternateu45flowsType(p1.toSeq map { scalaxb.fromXML[models.AlternateSequenceType](_, scalaxb.ElemName(node) :: stack) },
        p2.toSeq map { scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) })
    
    override def writesAttribute(__obj: models.Alternateu45flowsType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: models.Alternateu45flowsType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.alternateu45flow flatMap { scalaxb.toXML[models.AlternateSequenceType](_, Some("http://xuse.sourceforge.net"), Some("alternate-flow"), __scope, false) },
        __obj.any flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, true) })

  }

  trait DefaultModelsRefu45alternateu45flowsTypeFormat extends scalaxb.XMLFormat[models.Refu45alternateu45flowsType] with scalaxb.CanWriteChildNodes[models.Refu45alternateu45flowsType] {
    val targetNamespace: Option[String] = Some("http://xuse.sourceforge.net")
    import scalaxb.ElemName._
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, models.Refu45alternateu45flowsType] = seq match {
      case node: scala.xml.Node => Right(models.Refu45alternateu45flowsType(scalaxb.fromXML[String]((node \ "@refId"), scalaxb.ElemName(node) :: stack),
        scalaxb.fromXML[String]((node \ "@condition"), scalaxb.ElemName(node) :: stack)))
      case _ => Left("reads failed: seq must be scala.xml.Node")
    }
    
    override def writesAttribute(__obj: models.Refu45alternateu45flowsType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      attr = scala.xml.Attribute(null, "refId", __obj.refId.toString, attr)
      attr = scala.xml.Attribute(null, "condition", __obj.condition.toString, attr)
      attr
    }

    def writesChildNodes(__obj: models.Refu45alternateu45flowsType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Nil


  }

  trait DefaultModelsExceptionu45flowsTypeFormat extends scalaxb.ElemNameParser[models.Exceptionu45flowsType] {
    val targetNamespace: Option[String] = Some("http://xuse.sourceforge.net")
    
    override def typeName: Option[String] = Some("exception-flowsType")

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[models.Exceptionu45flowsType] =
      phrase(rep(scalaxb.ElemName(Some("http://xuse.sourceforge.net"), "exception-flow")) ~ 
      rep(any(_.namespace != Some("http://xuse.sourceforge.net"))) ^^
      { case p1 ~ p2 =>
      models.Exceptionu45flowsType(p1.toSeq map { scalaxb.fromXML[models.AlternateSequenceType](_, scalaxb.ElemName(node) :: stack) },
        p2.toSeq map { scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) })
    
    override def writesAttribute(__obj: models.Exceptionu45flowsType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: models.Exceptionu45flowsType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      Seq.concat(__obj.exceptionu45flow flatMap { scalaxb.toXML[models.AlternateSequenceType](_, Some("http://xuse.sourceforge.net"), Some("exception-flow"), __scope, false) },
        __obj.any flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, true) })

  }

  trait DefaultModelsIncludeTypeFormat extends scalaxb.ElemNameParser[models.IncludeType] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XInclude")
    
    override def typeName: Option[String] = Some("includeType")

    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[models.IncludeType] =
      phrase(optTextRecord ~ 
      rep((((((scalaxb.ElemName(Some("http://www.w3.org/2001/XInclude"), "fallback")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[models.FallbackType](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })) | 
      (((any(_.namespace != Some("http://www.w3.org/2001/XInclude")) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack))) ~ 
      optTextRecord) ^^ 
      { case p1 ~ p2 => Seq.concat(Seq(p1), p2.toList) })) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      models.IncludeType(Seq.concat(p1.toList,
        p2.flatten,
        p3.toList),
        (node \ "@href").headOption map { scalaxb.fromXML[java.net.URI](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@parse").headOption map { scalaxb.fromXML[models.ParseType](_, scalaxb.ElemName(node) :: stack) } getOrElse { scalaxb.fromXML[models.ParseType](scala.xml.Text("xml"), scalaxb.ElemName(node) :: stack) },
        (node \ "@xpointer").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@encoding").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@accept").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        (node \ "@accept-language").headOption map { scalaxb.fromXML[String](_, scalaxb.ElemName(node) :: stack) },
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "href" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "parse" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "xpointer" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "encoding" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "accept" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) if key == "accept-language" => Nil
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) })
    
    override def writesAttribute(__obj: models.IncludeType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.href foreach { x => attr = scala.xml.Attribute(null, "href", x.toString, attr) }
      if (__obj.parse.toString != "xml") attr = scala.xml.Attribute(null, "parse", __obj.parse.toString, attr)
      __obj.xpointer foreach { x => attr = scala.xml.Attribute(null, "xpointer", x.toString, attr) }
      __obj.encoding foreach { x => attr = scala.xml.Attribute(null, "encoding", x.toString, attr) }
      __obj.accept foreach { x => attr = scala.xml.Attribute(null, "accept", x.toString, attr) }
      __obj.acceptu45language foreach { x => attr = scala.xml.Attribute(null, "accept-language", x.toString, attr) }
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: models.IncludeType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }

  def buildModelsParseTypeFormat = new DefaultModelsParseTypeFormat {}
  trait DefaultModelsParseTypeFormat extends scalaxb.XMLFormat[models.ParseType] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XInclude")
    
    def reads(seq: scala.xml.NodeSeq, stack: List[scalaxb.ElemName]): Either[String, models.ParseType] = seq match {
      case elem: scala.xml.Elem => Right(models.ParseType.fromString(elem.text, elem.scope))
      case _ => Right(models.ParseType.fromString(seq.text, scala.xml.TopScope))
    }
    
    def writes(__obj: models.ParseType, __namespace: Option[String], __elementLabel: Option[String],
        __scope: scala.xml.NamespaceBinding, __typeAttribute: Boolean): scala.xml.NodeSeq =
      scala.xml.Elem(scalaxb.Helper.getPrefix(__namespace, __scope).orNull, 
        __elementLabel getOrElse { sys.error("missing element label.") },
        scala.xml.Null, __scope, scala.xml.Text(__obj.toString))
  }

  trait DefaultModelsFallbackTypeFormat extends scalaxb.ElemNameParser[models.FallbackType] {
    val targetNamespace: Option[String] = Some("http://www.w3.org/2001/XInclude")
    
    override def typeName: Option[String] = Some("fallbackType")

    override def isMixed: Boolean = true

    def parser(node: scala.xml.Node, stack: List[scalaxb.ElemName]): Parser[models.FallbackType] =
      phrase(optTextRecord ~ 
      rep((((((scalaxb.ElemName(Some("http://www.w3.org/2001/XInclude"), "include")) ^^ 
      (x => scalaxb.DataRecord(x.namespace, Some(x.name), scalaxb.fromXML[models.IncludeType](x, scalaxb.ElemName(node) :: stack)))) ~ 
      optTextRecord) ^^ 
        { case p1 ~ p2 => Seq.concat(Seq(p1),
        p2.toList) })) | 
      (((any(_.namespace != Some("http://www.w3.org/2001/XInclude")) ^^ (scalaxb.fromXML[scalaxb.DataRecord[Any]](_, scalaxb.ElemName(node) :: stack))) ~ 
      optTextRecord) ^^ 
      { case p1 ~ p2 => Seq.concat(Seq(p1), p2.toList) })) ~ 
      optTextRecord ^^
      { case p1 ~ p2 ~ p3 =>
      models.FallbackType(Seq.concat(p1.toList,
        p2.flatten,
        p3.toList),
        scala.collection.immutable.ListMap((node match {
          case elem: scala.xml.Elem =>
            elem.attributes.toList flatMap {
              
              case scala.xml.UnprefixedAttribute(key, value, _) =>
                List(("@" + key, scalaxb.DataRecord(None, Some(key), value.text)))
              case scala.xml.PrefixedAttribute(pre, key, value, _) =>
                val ns = elem.scope.getURI(pre)
                List(("@{" + ns + "}" + key, scalaxb.DataRecord(Option[String](ns), Some(key), value.text)))
              case _ => Nil
            }
          case _ => Nil
        }): _*)) })
    
    override def writesAttribute(__obj: models.FallbackType, __scope: scala.xml.NamespaceBinding): scala.xml.MetaData = {
      var attr: scala.xml.MetaData  = scala.xml.Null
      __obj.attributes.toList map {
        case (key, x) => attr = scala.xml.Attribute((x.namespace map { __scope.getPrefix(_) }).orNull, x.key.orNull, x.value.toString, attr) }
      attr
    }

    def writesChildNodes(__obj: models.FallbackType, __scope: scala.xml.NamespaceBinding): Seq[scala.xml.Node] =
      __obj.mixed.toSeq flatMap { x => scalaxb.toXML[scalaxb.DataRecord[Any]](x, x.namespace, x.key, __scope, false) }

  }


}

